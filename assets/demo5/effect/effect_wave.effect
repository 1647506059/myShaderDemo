// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

CCEffect %{
  techniques:
  - passes:
    - vert: vs
      frag: fs
      blendState:
        targets:
        - blend: true
      rasterizerState:
        cullMode: none
      properties:
        texture: { value: white }
        texture2: { value: white }
        alphaThreshold: { value: 0.5 }
        u_time: {value: 0.5 }
}%


CCProgram vs %{
  precision highp float;

  #include <cc-global>
  #include <cc-local>

  in vec3 a_position;
  in vec4 a_color;
  out vec4 v_color;

  #if USE_TEXTURE
  in vec2 a_uv0;
  out vec2 v_uv0;
  #endif

  void main () {
    vec4 pos = vec4(a_position, 1);

    #if CC_USE_MODEL
    pos = cc_matViewProj * cc_matWorld * pos;
    #else
    pos = cc_matViewProj * pos;
    #endif

    #if USE_TEXTURE
    v_uv0 = a_uv0;
    #endif

    v_color = a_color;

    gl_Position = pos;
  }
}%


CCProgram fs %{
  precision highp float;

  #include <alpha-test>
  #include <texture>
  #include <cc-global>

  uniform inputData{
    float u_time;
  };

  in vec4 v_color;
  in vec2 v_uv0;
  uniform sampler2D texture;
  uniform sampler2D texture2;

  float random(vec2 st){
    // dot 
    // fract 取小数
    return fract(sin(dot(st.xy, vec2(12.9898 , 78.233))) * 4358.5453123);
  }

  void main () {
    vec3 color = vec3(0.);

    // 弄个t接收cc_time.x, *= 0.6是因为正常速太快，变慢点
    float t = cc_time.x * 0.6;

    // 自定义脚本传入时间
    // float t = u_time;

    // 取噪声图的xy两个通道，作为对场景图取样所用uv的偏移值
    // vec2(.5,.1) 是随便写的一个方向向量，方向*时间 作为uv的偏移
    // 噪声图设置 WrapMode = Repeat 否则偏移值超过vec2(1.,1.)之后就取不到值了，要改成repeat才可以取值
    vec2 off = texture2D(texture2,v_uv0+ t * vec2(.5,.1)).xy;
    // 偏移值缩放0.1倍，减弱波纹
    off *= .1;

    color += texture2D(texture,off + v_uv0).xyz;

    // 水面的明暗变化，镜头越近颜色越暗
    // 参数0-1是正好 从黑到白的，用-.5->1.3这个范围，色值就是不太黑到不太白，免得颜色太极端
    color *= smoothstep(-.5,1.3,v_uv0.y) - .3;

    // 添加一些水面的浮沫
    // 白色泡沫的uv 取名mouv
    vec2 mouv = v_uv0;
    // 做y轴分行，原理见彩虹那篇帖子
    mouv.y *= 20.;
    // n3 就是行id
    float n3 = floor(mouv.y);
    // n4就是用行id随机一个对应的随机值出来，每行一个随机值作为行的运动速度
    // 所以对于y轴在同一行（注意上面*=20，所以共20行），我们这里计算出一个改行的运动速度，放在这备用
    float n4 = random(vec2(n3 , n3)) + .3;

    // baseuv做变换对噪声图取值
    vec2 baseuv = v_uv0;
    // 让噪声图x轴重复四次，y轴重复三次
    vec2 scale = vec2(4. , 3.);
    baseuv = baseuv * scale;

    // 取值用的uv加上向左的移动 t是上面用过的那个cc_time.x哈，*0.1不然太快了
    // n4是上面计算好的速度
    baseuv.x += t * .1 *n4;

    float c1 = texture2D(texture2,baseuv).x;
    // 大浪的值0-1，用smoothstep对大浪做个变换，只留下0-0.23的色值，大于0.23的都变成了纯黑色
    // c1值输入函数曲线后，0-0.23范围输出了0->1的值，越黑的地方越亮，亮的就变黑色
    c1 = smoothstep(0.23 , 0. , c1);
    color += vec3(c1);

    gl_FragColor = vec4(color,1.);
  }
}%
